'use strict';
if (typeof module!='undefined' && module.exports) var LatLon = require('./latlon-ellipsoidal.js'); // CommonJS (Node)


// I knew the maths was well beyond me, but hoped to tie code back to Karney 2011 paper (Algorithms
// for Geodesics); however, geographiclib code is seriously inpenetrable, and beyond my capabilities
// to relate back to the paper.
//
// http://geographiclib.sourceforge.net/html/js/tutorial-2-interface.html



LatLon.prototype.distanceTo = function(point) {
    if (!(point instanceof LatLon)) throw new TypeError('point is not LatLon object');
};


LatLon.prototype.direct = function(distance, initialBearing) {
    var φ1 = this.lat.toRadians(), λ1 = this.lon.toRadians();
    var α1 = initialBearing.toRadians();
    var s = distance;

    var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b, f = this.datum.ellipsoid.f;










    var e2 = f * (2 - f);    // eccentricity squared
    var eʹ2 = e2 / (1 - e2); // second eccentricity squared


    var sinα1 = Math.sin(α1);
    var cosα1 = Math.cos(α1);

    var tanβ1 = (1-f) * Math.tan(φ1);                 // 6
    var cosβ1 = 1 / Math.sqrt((1 + tanβ1*tanβ1));
    var sinβ1 = tanβ1 * cosβ1;

    var sinα0 = sinα1 * cosβ1;
    var cosα0 = Math.hypot(cosα1, sinα1 * sinβ1);

    var sinσ1 = sinβ1;
    var cosσ1 = sinβ1 !== 0 || cosα1 !== 0 ? cosβ1 * cosα1 : 1;
    var t = m.hypot(sinσ1, cosσ1);
    sinσ1 /= t;
    cosσ1 /= t;



    console.log('β1', Math.atan(tanβ1).toDegrees())


    var α0 = Math.atan2(sinα1*cosβ1, Math.sqrt(cosα1*cosα1+sinα1*sinα1*sinβ1*sinβ1));
    console.log('α0', α0.toDegrees())
    var σ1 = Math.atan2(sinβ1, cosα1*cosβ1);
    console.log('σ1', σ1.toDegrees())
    var ω1 = Math.atan2()

    // -----------------------------------------




    // -----------------------------------------



    var φ2 = 0;
    var λ2 = 0;
    var α2 = 0;
    return {
        point:        new LatLon(φ2.toDegrees(), λ2.toDegrees(), this.datum),
        finalBearing: α2.toDegrees(),
    };
};

function sinSeries(sinx, cosx, c) {
    // Evaluate
    // y = sum(c[i] * sin( 2*i * x), i, 1, n)
    // using Clenshaw summation.  N.B. c[0] is unused for sin series
    // Approx operation count = (n + 5) mult and (2 * n + 2) add
    var k = c.length;           // Point to one beyond last element
    var n = k - 1;
    var ar = 2 * (cosx - sinx) * (cosx + sinx); // 2 * cos(2 * x)
    var y0 = n & 1 ? c[--k] : 0, y1 = 0;        // accumulators for sum
    // Now n is even
    n = Math.floor(n/2);
    while (n--) {
      // Unroll loop x 2, so accumulators return to their original role
      y1 = ar * y0 - y1 + c[--k];
      y0 = ar * y1 - y0 + c[--k];
    }
    return 2 * sinx * cosx * y0; // sin(2 * x) * y0
  }

/**
 * Vincenty inverse calculation.
 *
 * @private
 * @param   {LatLon} point - Latitude/longitude of destination point.
 * @returns {Object} Object including istance, initialBearing, finalBearing.
 * @throws  {Error}  If formula failed to converge.
 */
LatLon.prototype.inverse = function(point) {
    var p1 = this, p2 = point;
    var φ1 = p1.lat.toRadians(), λ1 = p1.lon.toRadians();
    var φ2 = p2.lat.toRadians(), λ2 = p2.lon.toRadians();

    var a = this.datum.ellipsoid.a, b = this.datum.ellipsoid.b, f = this.datum.ellipsoid.f;

    var L = λ2 - λ1;
    var tanU1 = (1-f) * Math.tan(φ1), cosU1 = 1 / Math.sqrt((1 + tanU1*tanU1)), sinU1 = tanU1 * cosU1;
    var tanU2 = (1-f) * Math.tan(φ2), cosU2 = 1 / Math.sqrt((1 + tanU2*tanU2)), sinU2 = tanU2 * cosU2;

    var sinλ, cosλ, sinSqσ, sinσ, cosσ, σ, sinα, cosSqα, cos2σM, C;

    var λ = L, λʹ, iterations = 0;
    do {
        sinλ = Math.sin(λ);
        cosλ = Math.cos(λ);
        sinSqσ = (cosU2*sinλ) * (cosU2*sinλ) + (cosU1*sinU2-sinU1*cosU2*cosλ) * (cosU1*sinU2-sinU1*cosU2*cosλ);
        sinσ = Math.sqrt(sinSqσ);
        if (sinσ == 0) return 0;  // co-incident points
        cosσ = sinU1*sinU2 + cosU1*cosU2*cosλ;
        σ = Math.atan2(sinσ, cosσ);
        sinα = cosU1 * cosU2 * sinλ / sinσ;
        cosSqα = 1 - sinα*sinα;
        cos2σM = cosσ - 2*sinU1*sinU2/cosSqα;
        if (isNaN(cos2σM)) cos2σM = 0;  // equatorial line: cosSqα=0 (§6)
        C = f/16*cosSqα*(4+f*(4-3*cosSqα));
        λʹ = λ;
        λ = L + (1-C) * f * sinα * (σ + C*sinσ*(cos2σM+C*cosσ*(-1+2*cos2σM*cos2σM)));
    } while (Math.abs(λ-λʹ) > 1e-12 && ++iterations<200);
    if (iterations>=200) throw new Error('Formula failed to converge');

    var uSq = cosSqα * (a*a - b*b) / (b*b);
    var A = 1 + uSq/16384*(4096+uSq*(-768+uSq*(320-175*uSq)));
    var B = uSq/1024 * (256+uSq*(-128+uSq*(74-47*uSq)));
    var Δσ = B*sinσ*(cos2σM+B/4*(cosσ*(-1+2*cos2σM*cos2σM)-
        B/6*cos2σM*(-3+4*sinσ*sinσ)*(-3+4*cos2σM*cos2σM)));

    var s = b*A*(σ-Δσ);

    var α1 = Math.atan2(cosU2*sinλ,  cosU1*sinU2-sinU1*cosU2*cosλ);
    var α2 = Math.atan2(cosU1*sinλ, -sinU1*cosU2+cosU1*sinU2*cosλ);

    α1 = (α1 + 2*Math.PI) % (2*Math.PI); // normalise to 0...360
    α2 = (α2 + 2*Math.PI) % (2*Math.PI); // normalise to 0...360

    s = Number(s.toFixed(3)); // round to 1mm precision
    return { distance: s, initialBearing: α1.toDegrees(), finalBearing: α2.toDegrees() };
};


/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */

/** Extend Number object with method to convert numeric degrees to radians */
if (Number.prototype.toRadians === undefined) {
    Number.prototype.toRadians = function() { return this * Math.PI / 180; };
}

/** Extend Number object with method to convert radians to numeric (signed) degrees */
if (Number.prototype.toDegrees === undefined) {
    Number.prototype.toDegrees = function() { return this * 180 / Math.PI; };
}

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  */
if (typeof module != 'undefined' && module.exports) module.exports = LatLon; // CommonJS (Node)
if (typeof define == 'function' && define.amd) define([], function() { return LatLon; }); // AMD
